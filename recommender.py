# -*- coding: utf-8 -*-
"""DMAP FA20 Final Project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1koV9jr0QzMv_QV2dbvVDMbT7rhIQLlhX
"""

# Keep this code cell here
# Project title will be used by the reviewer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics.pairwise import linear_kernel
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_extraction.text import TfidfVectorizer
import matplotlib.pyplot as plt
import matplotlib
import numpy as np
import pandas as pd

from os import system, name


PROJECT_TITLE = "Recommending Anime Based on Watch History"
NOTEBOOK_ID = "1koV9jr0QzMv_QV2dbvVDMbT7rhIQLlhX"
VERSION = "FA20.10.10.2020"

"""
---
# Project Introduction

![image.png](data:image/png;base64,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)
## The Scope
This project will focus on building an anime recommender. Given a user's list of anime watched, it will attempt to return another list of anime that it thinks the user will like based on factors such as genre and rating.

### The Data
The dataset itself was sourced from Kaggle, with the URL given below in the code. The data was scraped from [myanimelist.net](https://myanimelist.net), a site that acts as a database for anime containing numerous data points for each series and show that have aired and are yet to air. 

The csv dataset will be downloaded by pandas `read_csv()` function. 

"https://www.youtube.com/embed/0ySOsNMHEuQ"

To begin this project, we begin by including the standard data science libraries `numpy` and `pandas`.

The anime recommender requires TF-IDF work as well as cosine similarity metrics in order to build models and define how entries (here, anime) are similar to each other in order to give recommendations to the user. 
"""


"""
# Data Acquisition, Selection, Cleaning

## Acquisition

The `install_data()` function uses a Google Drive URL to download a csv into a Pandas DataFrame. 

"""


def install_data():
    # Taken from https://www.kaggle.com/canggih/anime-data-score-staff-synopsis-and-genre/data/
    df = pd.read_csv(
        "http://drive.google.com/uc?export=download&id=1rj1wC5FyELyaigmIYkzxZuhNLs39rFJL")
    return df


df = install_data()
# df.head()

"""
## Selection and Cleaning

This portion of code will clean the dataset and manipulate the data into something more usable. 

`observe_data()` simply prints an overview of all the columns and how many missing values each has. 

`clean_data()` does the real work in creating a usable dataset. It first drops all rows with missing data. Unlike the cleaning lesson, a lot of the data is categorical (genre, name, etc.) and is therefore un-imputable: you cannot simply add in values based on those around it. Therefore it is only proper to drop these shows.  

Secondly, it drops several categories of data that will not contribute to building the TF-IDF model as well as those that aren't as useful to the user. 

Third, I begin preparing the data for the `CountVectorizer` using the sub-functions `split_on_comma()` and `mesh()` by meshing phrases into one and lowercasing them. This creates a "soup" of words that the Vectorizer can use to build and fit a model. 

This soup is necessary as there may be names or keywords that are similar (perhaps White Fox and White Snake as a contrived example) which need to appear differently to the Vectorizer. This soup makes "whitefox" and "whitesnake" out of these phrases so there is no confusion. 

After doing this to several columns, the `create_soup()` sub-function mashes all these soupy columns together to use in the `CountVectorizer`. 
"""


def observe_data(df):
    print(df.isna().sum())


def clean_data(df):

    # Drop any rows with missing values as this data is un-imputable
    df = df.dropna()

    # Convert genre entries from string to list of strings

    df = df.drop(['Type', 'Status', 'End airing', 'Starting season',
                  'Broadcast time', 'Producers', 'Sources', 'Duration',
                  'Members', "Favorites", 'Scored by', 'Score', 'Rating'], axis=1)

    # "Action,Drama,Romance" -> ["Action", "Drama", "Romance"]
    def split_on_comma(col):
        old = list(df[col])
        new = [g.split(',') for g in old]

        df.drop(col, axis=1, inplace=True)
        df[col] = new

    # "actiondramaromance, .."
    def mesh(l):
        return [str.lower(i.replace(" ", '')) for i in l]

    to_change = ['Genres', 'Licensors', 'Studios', 'Description']

    for col in to_change:
        split_on_comma(col)
        df[col] = df[col].apply(mesh)

    # Creates a word soup of many different columns for the Vectorizer
    def create_soup(df):
        return ' '.join(df['Description']) + ' ' + ' '.join(df['Genres']) + ' ' + \
            ' '.join(df['Studios']) + ' ' + ' '.join(df['Licensors'])

    df['Soup'] = df.apply(create_soup, axis=1)

    return df


new_df = clean_data(df.copy())

"""
# Data Exploration

This is a very detailed dataset of anime, though it is not very big. It has many columns of data for those who wish to use them, but for simplicity I have removed much of the columns. 

The columns contain pertinent information such as the name of the anime, the number of episodes, when the anime starting airing, the genres it encompasses, who made it, who licensed it and a description. 

The licensor I kept as I could use it in the "soup" to give an idea to the user where they can stream the anime, i.e. Funimation or Crunchyroll. 
"""

# new_df.head()

"""
# Data Analysis

## Building the Model

My goal is to recommend similar anime to an anime list passed in. However, I will consider multiple data points other than genre. I will consider plot, licensor, and studio to decide on what anime to recommend to the user. 

The model would be trained on the data points listed in the analysis section. I would train the model to favor shows with similar genres and plots. 

I use `CountVectorizer()` instead of `TfidfVectorizer()` because TF-IDF would reduce the weights of those genres, licensors, etc. if they appeared a lot, which doesn't make sense. 

## Building the Cosine Similarity Matrix

After this, I build a cosine similarity matrix that gives a sense of how anime could be similar based on the model and how similar each anime is to each other. 
"""


def build_tfidf_matrix(df):
    vec = CountVectorizer(stop_words='english')
    matrix = vec.fit_transform(df['Soup'])
    return matrix


matrix = build_tfidf_matrix(new_df)


def build_cossim(df):
    cossim = cosine_similarity(matrix, matrix)
    # Construct a reverse map of indices and anime titles
    indices = pd.Series(df.index, index=df['Title'])
    return cossim, indices


cossim, indices = build_cossim(new_df)

"""
# Final Processing 

get_recommendations() is the function that builds all the fun stuff for the user to see: their list of recommended anime. 
"""


def get_recommendations(title, n=10, nsfw=False, prefer_finished=False, cossim=cossim, debug=False):

    try:
        idx = indices[title]  # get index of anime from df that matches title
    except KeyError:
        return "We couldn't find that anime. Please try another!"

    # get cos-sim scores of all other anime wrt `title` anime
    scores = list(enumerate(cossim[idx]))

    # Sort anime in descending order based on cos-sim scores
    scores = sorted(scores, key=lambda x: x[1], reverse=True)

    assert n > 0, "Please choose a number greater than 0"
    scores = scores[1:(n + 1)]  # Return n anime

    idxs = [i[0] for i in scores]  # get anime indices
    final_df = df.iloc[idxs]

    if nsfw:
        final_df = final_df[final_df['Rating'] != 'R']

    if prefer_finished:
        final_df = final_df[final_df['Status'] == 'Finished Airing']

    # https://www.datacamp.com/community/tutorials/recommender-systems-python
    # WR = (v/(v+m) * R) + (m/(v + m) * C) => IMBD's Weighted Ranking formula
    C = final_df['Score'].mean()
    if debug:
        print("C: ", C)
    m = final_df['Scored by'].quantile(0.25)
    if debug:
        print("M: ", m)
    final_df = final_df[final_df['Scored by'] >= m]

    v = final_df['Scored by']
    R = final_df['Score']

    final_df['Weighted score'] = (v/(v+m) * R) + (m/(m + v) * C)
    final_df = final_df.sort_values('Weighted score', ascending=False)

    return final_df[['Title', 'Type', 'Status', 'Start airing', 'Licensors',
                     'Studios', 'Genres', 'Rating', 'Weighted score']]\
        .reset_index().drop('index', axis=1)

# Where the user can get recommendations


def recommend():
    df = install_data()
    new_df = clean_data(df)
    matrix = build_tfidf_matrix(new_df)
    cossim, indices = build_cossim(df)

    print("What anime did you like in the past?")
    title = str(input())
    print("Would you prefer to keep the age rating appropriate? y/n")
    nsfw_bool = True if str(input()) == "y" else False
    print("Do you prefer finished anime only? y/n")
    finished_bool = True if str(input()) == 'y' else False
    print("Finally, up to how many anime recommendations would you like to see?")
    num = int(input())
    print("Generating recommendations for you! ...")

    print(get_recommendations(title, n=num,
                              nsfw=nsfw_bool, prefer_finished=finished_bool))


_ = system('clear')
recommend()

"""
# Conclusion

The output list of recommendations is very useful and valuable. Instead of only recommending shows from the same series, it also recommends similar anime based on genre, description, studio, and licensors. 

Creating a word soup out of those four categories and using TF (I didn't use IDF) I created a project that would recommend similar anime while also letting the user set some parameters such as age-rating as well as anime still airing, as some like to binge a show once it has finished airing. 


# Future Improvements 

The dataset is very clean but also very small (~1000 entries). I would like to find/create a just-as-clean but much larger dataset that would be much more useful. 

Moreover, I would like to consider start date in the future, so that anime from the same time period are recommended as well. 

Furthermore, I'd like to make it so that the user can input a list of anime and get recommendations based on that list instead of a single anime. 

# References

- The TF-IDF Lesson
- https://www.datacamp.com/community/tutorials/
recommender-systems-python
- https://www.kaggle.com/canggih/anime-data-score-staff-synopsis-and-genre/data/
- https://www.myanimelist.net
- https://heartbeat.fritz.ai/recommender-systems-with-python-part-i-content-based-filtering-5df4940bd831
"""
